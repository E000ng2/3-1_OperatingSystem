# 대용량 저장 장치 관리
## 1. 저장 장치 개요
- 목적
  - 프로그램과 데이터를 보조적으로 저장
- 특성
  - 대용량 장치
    - 하드디스크, SSD, 자기데이프, CD, RAID, USB 스틱 등
    - GB ~ Tera Byte
    - 주기억장치의 1000배
    - 데이터 베이스나 파일 저장
  - 비 휘발성 영구 기억 장치
  - 가상 메모리의 스왑 공간
- 성능과 신뢰성
  - 입출력 병목 문제(I/O bottleneck) - 시스템 성능 영향
    - 저장장치의 입출력에 과부하가 걸려 있는 상태
    - CPU 유휴 시간을 늘리고 시스템 전체를 느리게 함

  - 병목 현상 해결 방법
    - 주기억장치 메모리 늘리기
    - 디스크 캐시 늘리기
    - 디스크 스케줄링
    - SSD와 같은 빠른 저장 장치 사용
    - RAID와 같은 병렬 저장 장치 사용

  - 데이터의 신뢰성 - 시스템 신뢰성 영향
    - 저장 장치의 고장

  - 데이터의 신뢰성을 높이는 방법
    - 디스크 미러링(disk mirroring) - RAID 1레벨

      1. 2개의 디스크에 항상 동일한 데이터 저장
      2. 디스크 1이 고장난 경우 디스크 0의 데이터를 기록하여 복구

    - RAID(Redundant Array of Inexpensive Disks)
      
      1. 데이터 블록들과 1개의 패리티 블록이 디스크에 걸쳐 분산 배치
      2. 디스크2가 고장이 난 경우, 같은 줄에 잇는 데이터와 패리티를 이용해 정보 복구

## 2. 하드 디스크 장치
- 디스크 제어 모듈과 디스크 매체 모듈고 구성
  - 디스크 제어 모듈
    - 호스트로 부터 명령을 받아 디스크 매체 모듈 제어
    - 디스크 캐시와 호스트 사이의 입출력
    - 구성 - 프로세서, 입출력 인터페이스, 디스크 캐시, 모터 코일 등
  - 디스크 매체 모듈
    - 디스크 헤드를 움직여 물리적인 입출력 시행
    - 디스크 캐시와 디스크 헤드 사이의 입출력
    - 구성 - 플래터, 디스크 헤드, 암, 스핀들, 구동기 등
    - 모들 팰래터는 등각속도로 함께 회전

- 존 비트 레코딩
  - 바깥쪽 존에 트렉당 섹터 수를 더 많게 포멧 -> 저장 공간 확대와 입출력 속도 향상
- 디스크 물리 주소
  - CHS(Cylinder-Head-Sector)물리 주소
    - 디스크의 목표 섹터를 나타내는 주소 
    - 디스크 장치에서 사용하는 주소
  - 논리 블록 주소(LBA, Logical Block Address)
    - 디스크의 모든 섹터를 일차원으로 펼치고, 여러 섹터를 블록 단위로 묵고 불록을 0번부터 번호 매긴 주소
    - 운영 체제에서 사용하는 주소
  - 논리 블록 주소 -> 디스크 물리 주소 변환
    - 디스크 장치에서 실행
- 디스크 용량 계산
  - 실린더 개수 X 실린더당 트랙 수 X 트랙당 섹터 수 X 섹터 크기
    ```
    예제 1
    다음 조건의 경우 디스크 용량은 ? 
    * 실린더 - 1000개
    * 실린더 당 트랙 수 - 8개
    * 트랙당 섹터 수 - 200개
    * 섹터 크기 - 512Byte

    디스크 용량 = 1000 X 8 X 200 X 512Byte = 800MB

    예제 2
    * 실린더 - 4000개
    * 실린더 당 트랙 수 - 2개
    * 트랙당 섹터 수 - 2000개
    * 섹터 크기 - 521Byte

    디스크 용량 = 4000 X 2 X 2000 X 512 = 8GB
    ```
- 디스크 입출력 과정 및 성능 파리미터
  - 일반적인 구성
    - 명령(읽기/쓰기), 논리 블록 번호(LBA), 호스트 메모리 주소
  - 디스크 입출력 명령을 처리하는 과정
    
    1. 프로세서가 논리 블록 번호를 CHS 물리 수조로 바꾸고 장치 제어 및 입출력 시행
    2. 탐색(seek) - 디스크 헤드를 목표 실린더로 이동/ 매우 느림림
    3. 회전 지연(rotational latency) - 플래터가 회전하여, 헤드 밑에 목표 섹터가 도달할 때까지 대기
    4. 전송(Transfer) - 디스크 헤드와 호스트 사이의 데이터 전송
    5. 오버헤드(overhead) - 디스크 프로세서가 호스트에서 명령을 받고 해석하는 등의 부가 과정

- 탐색(seek)
  - 디스크 장치 내 모터를 이용하여 디스크 헤드가 현재 실린더에서 목표 실린더로 이동하는 과정
  - 탐색 거리(seek distance)
    - 이동하는 실린더 개수
  - 탐색 시간(seek time)
    - 전체적으로 탐색하는 거리에 선형적으로 비례(5ms 내외)

- 회전 지연(rotational latency)
  - 탐색 후 플래터가 회전하여, 헤드 및에 목표 섹터가 도달할 때까지 기다리는데 걸리는 시간
  - 디스크 회전 속도 - 분당 회전수, rpm
  - 평균 회전 지연 시간 계산
    - $\frac{1}{2}$ 회전 시간
    - 1회전 시간 = $\frac{60초}{회전 속도(rpm)}$
    - 예) 7200rpm 디스크의 경우, 1회전 시간 = $\frac{7200}{60} = 8.33ms, 평균 회전 시연 시간 = $\frac{8.33ms}{2} = 4.17ms$

- 전송과 오버헤드
  - 내부 전송 시간
    - 예) 트랙 당 섹터 : 1000개, 섹터 512Byte, 회전 속도 : 7200rpm
    - 한 트랙 크기 : 1000 x 512Byte = 약 500KB
    - 1회전 시간 : $\frac{60초}{7200}$ = 8.3ms
    - 내부 전송 속도 : $\frac{500KB}{8.3ms}$ = 약 60MB/s
  - 외부 전송 시간
    - 디스크 캐시와 호스트 컴퓨터 사이에 데이터가 전송되는 시간
    - 호스트 컴퓨터가 연결되는 I/O 버스의 속도에 달려 있음
  - 오버 헤드 시간
    - 디스크 장치가 호스트로부터 명령을 받고 해석하는 시간
    - 요청 블록들이 동일 실린더에 있는 경우 헤드에서 다른 헤드로 변경되는 시간 등
    - 매우 작기 때문에 일반적으로 디스크 입출력 시간에서 배제

- 디스크 액세스 시간
  - 목표 섹터에 접근하여 읽거나 쓰기까지 걸리는 시간
  - 탐색시간 + 회전 지연 시간 + 내부 전송 시간
- 입출력 응답 시간
  - 호스트나 응용 프로그램 입장에서 디스크 입출력에 걸리는 전체 시간
  - 탐색시간 + 회전 지연 시간 + 전체 전송 시간 + 오버헤드

```
평균 디스크 액세스 시간과 평균 디스크 응답 시간 계산
* 평군 디스크 탐색 시간 : 제조업체에서 명시한 것으로 5ms
* 디스크의 회전 속도 : 10000rpm
* 트랙당 섹터 수 : 1000개
* 섹터 : 512Byte
* 디스크 장치와 호스트 사이의 인터페이스 전송 속도 : 100MB/s
* 디스크 장치의 오버헤드 : 0.1ms

디스크 액세스 시간 : 탐색시간 + 회전 지연 시간 + 내부 전송 시간
디스크 응답 시간 : 탐색시간 + 회전 지연 시간 + 전체 전송 시간 + 오버헤드

탐색 시간 : 5ms
1회전 시간 : 60 / 10000 = 6ms
회전 지연 시간 : 6 / 2 = 3ms
내부 전송 속도 : 1000 * 0.5KB / 6ms = 약  83.3MB/초
1섹터를 읽는데 걸리는 내부 전송 시간 = 0.5KB/83.3MB = 0.006ms
1섹터를 호스트로 보낼 때 걸리는 외부 전송 시간 = 0.5KB/100MB = 0.005ms

액세스 시간 : 5 + 3 + 0.006 = 8.006ms
응답 시간 : 5 + 3 + + 0.006 + 0.005 + 0.1  = 8.111ms
```

2 디스크 스케줄링 알고리즘
- 디스크 큐와 디스크 스케쥴링
  - 디스크 스케쥴링의 기본 목표 
    - 디스크 입출력의 처리율 항상
    - 디스크 입출력 응답시간 줄이기

  - 디스크 큐 : 도착하는 여러 디스크 입출력 요청을 저장하는 큐
  - 디스크 스케쥴링
    - 큐에 저장된 입출력 요청들의 목표 실린더 위치를 고려하여, 디스크 암이 움직이는 평균 탐색 거리를 최소화하여, 평균 디스크 탐색 시간과 평균 디스크 액세스 시간이 줄여, 디스크 처리율 향상

  - 디스크 스케줄링 알고리즘 - 평균 탐색 거리 기준으로 평가
    - FCFS(First Come First Serve)
      
      디스크 큐에 도착한 순서대로 요처들을 처리

      +)구현이 쉽고, 기아가 없고, 공평

      -)성능이 좋지 않음
    - SSTE(Shortest Seek Time First)

      현재 디스크 헤드가 있는 실린더에서 가장 가까운 요청 선택

      +) 성능이 매우 우수

      -) 디스크 헤드에서 멀리 있는 요청들에 기아 발생 우려, 바깥쪽 실린더에 대한 요청들은 오래 기다릴 수 있음

    - SCAN

      맨 바깥쪽 실린더의 요청에서 시작하여 안쪽 실린더로 요청을 처리 후 안쪽 끝까지 이동 -> 다시 바깥쪽 방향으로 요청을 처리하면서 끝 실린더까지 이동

      +) SSTF에 비해 균등한 입출력 서비스

      -) 양 끝쪽 실린더의 요청들은 중간에 위치한 요청들보다 선택될 확률 낮음

    - LOOK

      현재 이동 방향에 더 이상의 요청이 없는 경우 즉시 이동 방향 변경

      +) SCAN 처럼 작동, 맨 끝 실린더로 이동하는 단점 보완

    - C-SCAN

      한 방향(맨 바깥쪽 실린더에서 맨 안쪽 실린더로)으로만 이동하면서 요청 처리

      +) 중간 실린더의 요청들이 양끝보다 더 높은 확률로 서비스되는 SCAN의 단점 보완
    
    - C-LOOK

      LOOK과 C-SCAN의 결합

      한 방향(바깥쪽에서 안쪽으로)으로만 서비스, 이동 방향에 요청이 없으면 즉각 이동 방향 수정

      **FCES : 처리율 낮음 / SSTF : 처리율 최고 높음**

## 4. SSD 저장 장치
- SSD의 특징
  - 플래시 메모리(flash memory)를 저장소로 하는 비휘발성 기억 장치
  - 메모리 계층 구조의 최하위 단에 위치하는 보조 기억 장치
  - 순수 반도체 기억 장치
    - 기계 부품 없음
    - 디스크 보다 보가, 입출력 속도 5~50배 빠름
- SSD장치의 구조와 인터페이스
  - 플래시 메모리
    - SSD 내부의 저장소, SSD 제어기 내 플래시 제어기에 의해 입출력
  - DRAM 캐시 - 읽고 쓸 데이터의 임시 저장
  - 호스트 인터페이스
    - SATA(Serial ATA), SAS(Serial attached SCSI), PCI(PCI express)
  - SSD 제어기
    - SSD 장치에서 가장 중요한 부분, 제조업체의 경쟁력으로 비공개
    - 논리 블록 주소를 물리 블록 주소로 변환. 블록 입출력, 호스트와의 입출력, 웨어레벨링. 가비지 컬렉션 등

- SSD 메모리의 논리 구조
  - SSD의 플레시 메모리
    - 여러 블록(Block)으로 구성 - 블록(Block)은 여러 페이지(page)로 구성
    - 블록 크기 : 128KB ~ 256KB
    - 페이지크기 : 4KB ~ 16KB
  - 페이지는 읽고 쓰는 단위
    - 운영체제가 한 바이트를 읽고자 해도 SSD는 한 페이지 단위로 읽음
    - 모든 페이지에 대한 액세스 시간 동일
  - 주소 뱐환 
    - SSD는 운영체제로부터 발생된 논리 블록 번호를 플래시 메모리 블록번호와 페이지 번호로 변환하여 액세스
    - 주소 뱐환 테이블 이용

- SSD 입출력 동작
  - 페이지 읽기(read) - 페이지 단순 읽기
  - 블록 지우기(erase) - SSD제어기 내부에서만 이루어지는 과정으로 운영체제에서는 보이지 않음
    - 플래시 메모리가 데이터를 지우는 단위 : 블록
    - 운영체제는 읽기와 쓰기만 가능
  - 페이지 쓰기/ 프로그램(write/program)
    - 페이지 쓰기 - 프로그램이라고 부름, 페이지 단위로 이루어지며 빈페이지에만 쓰기 가능
    - 처음 페이지에 쓰는 경우 - SSD제어기는 빈 페이지를 찾고 그 곳에 기록
  - 기록된 페이지를 수정하는 경우
    1. 페이지 읽기(read) - SSD 제어기의 메모리로 페이지 읽기
    2. 페이지 수정(modify) - SSD 제어기의 메모리에서 페이지 수정
    3. 페이지 쓰기(write) - 빈 페이지를 찾아 수정된 페이지 기록
    4. 이전 페이지를 'dirty 또는 stale'로 표시 
  
  - 페이지 수정 시 현재 페이지를 지우기 쓰지 않고, 다른 빈 페이지에 쓰기를 하는 이유
    - 플래시 메모리의 블록은 쓰기나 지우기가 반복될 때 수명 단축
    - 여러 페이지로 쓰기를 분산시킬 필요 있기 때문
 
- 블록 지우기
  - 쓰기와 지우기는 다른 시능
  - 지우기의 단위 - 블록 단위로 지움
    - 지울 때 높은 전압이 걸려 주변 페이지의 훼손 때문에 블록 단위로 지움

  - 운영체제는 SSD에 읽기와 쓰기만 가능
    - 블록 지우기는 SSD 내부에서 가비지 컬렉션을 수행할 때
    - 빈 블록을 만들기 위해 이루어지는 SSD 내부 동작

- 가비지 컬렉션(garbage collection)
  - 불록 내 빈 페이지가 없게 될 때, 블록 내 dirty 페이지들을 제거하여 빈 블록을 만드는 과정
  - SSD 제어기에 의해 수행 
  - 과정
    
    1. 데이터가 저장된 페이지(valid페이지)들을 다른 블록의 빈 페이지로 복사
    2. 원본 블록 지우기(erase) -> 완전한 할당 가능 블록 생성

- 웨어 레벨링과 SSD의 용도
  - 플래시 메모리의 수며엥 관한 특징
    - 플래시의 블록은 쓰기나 지우기 횟수에 비례하여 닳아(wear)감
  - 웨어레벨링(wear leveling, 균등 쓰기 분배)
    - 플래시 메모리의 모든 블록에 걸쳐 쓰기를 균등하게 분배
    - 특정 블록에 과도한 쓰기를 막아 플래시 메모리의 고장이나 데이터 손실 예방 기법
    - SSD 제어기에 의해 실행
    - 블록마다 지우기 횟수 기억
    - 쓰기 시 지우기 횟수가 적은 블록 선택
  - SSD 용도
    - 읽기가 많은 운영체제 코드나 프로그램의 설지에 적합
    - 백업 저장 장치에 적합하지 않음
    - 수정 작업이나 많은 스왑 영역이나 임시 저장 파일 시스템이 적합하지 않음


  

