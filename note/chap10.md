# 가상 메모리
## 1. 물리 메모리의 한계
- 컴퓨터에 설치할 수 있는 물리 메모리의 최대 크기
  
  CPU주소 버스 크기에 달려 있음. 실제 컴퓨터는 비용문제로 최대량이 미치치 못함.
  
  - 32bit CPU 물리 메모리 최대량 : 4GB
  
  - 64bit CPU 물리 메모리 최대량 : $2^{24}$TB

- 물리 메모리의 한계 극복
  - 설치된 물리 메모리보다 큰 프로세스를 실행? yes
  - 프로세스들을 합친 크키가 설치된 물리 메모리보다 클 때 이들 모두 실행? yes

## 2. 가상 메모리 개념
물리 메모리 크기의 한계를 극복하기 위한 해결책

- 가상 매모리 기법의 핵심
  - 물리 메모리를 디디스크 공간으로 확장
  - 스와핑(swapping)
  1. 운영체제는 물리 메모리 영역을 하드 디스크로 연장
  2. 프로세스 실행시 프로세스 일부만 물리 메모리 적재
  3. 물리 메모리의 일부분을 하드 디스크로 옮김으로서 물리 메모리의 빈 영역 확보
  4. 스왑 영역 : 물리 메모리를 확장하여 사용하는 디스크 영역
  5. 사용자는 무한대의 메모리가 있는 것으로 착각
   
- 가상 메모리 구현
  - 요구 페이징(demand paging) = 페이징 + 스와핑(swapping)
  - 요구 세그먼테이션(demand segmentation) = 세그먼트 스와핑

## 3. 요구 페이징
현재 실행 필요한 일부 페이지만 메모리에 적재하고 나머지는 하드디스크에 두고 페이지가 필요할 때 메모리에 적재하는 방식. 프로세스 페이지가 있는 디스크 영역 = 스왑 영역 + 실행 파일

- 페이지 테이블 항목
  - present/valid bit : 해당 페이지가 물리 메모리에 있는지 여부 
    - 1 : 프레임 번호의 메모리에 있음
    - 0 : 디스크에 있음

  - modified/dirty bit : 해당 페이지가 수정되었는지 여부
    - 1 : 프레임에 적재된 이후 수정됨 - 나중에 쫓겨날 때 스왑 아웃(스왑 영역에 저장)
    - 0: 수정된적이 없음 - 스왑 영역에 저장될 필요 없음

  - physical address
    - present bit = 1 : 적재되어 있는 프레임 번호
    - present bit = 0 : 디스크 블록 번호
- 페이지 폴트(page fault)
  - CUP가 액세스하려는 페이지가 물리 메모리에 없을 때 발생. MMU에서 논리 주소를 물리 주소로 바꾸는 과정에서 발생
    - 스왑 영역이나 실행 파일로부터 빈 프레임에 페이지 적재
  - 스왑 인(swap-in) = page-in
    - 페이지를 스왑 영역에서 프레임으로 읽어 들이는(복사) 행위
  - 스왑 아웃(swap-out) = page-out
    - 프레임에 저장된 페이지를 스왑 영역에 저장하고 프레임을 비우는 행위
  
- 실행
    
    1. 프로세스의 시작 페이지를 물리 메모리에 적재
    2. 여러번의 페이지 폴트를 통해 실행 파일로부터 페이지들 적재
    3. 메모리가 부족하면 스왑-아웃/ 스왑-인
    4. (modified가 1인)페이지가 희생 페이지로 선택된 경우 : 스왑-아웃(스왑 영역에 저장)
    5. 코드가 적재된 페이지(읽기 전용)이나 수정되지 않은 페이지가 희생 페이지로 선택된 경우 : 그 페이지는 프레임에서 버림. 이후 스왑 영역이나 실행 영역에서 적재

- 쓰기 시 복사 (COW, copy on write)
  - 부모 프로세스가 fork() 시스템 호출로 생성
  - fork() 자식 프로세스의 메모리 생성 방법
    
    
    1. 완전 복사 : 부모 프로세스의 모든 페이지를 완전히 복사

        많은 응용프로그램들이 fork() 후 생성된 자식 프로세스가 execlp()를 호출하여 곧 바로 다른 프로그램을 실행하도록 작성되기 때문에 비효율적임.
    2. 쓰기 시 복사 : 부모 프로세스의 페이지 테이블만 복사. 자식이나 부모가 페이지를 수정할 때 부모 프레임을 복사.
    
        프로세스 생성이 매무 빠름. 부모와 자식 프로세스가 둘 다 읽기만 하는 페이지는 새로운 프레임을 할당할 필요가 없으므로 메모리 절약

- 페이지 폴트와 스래싱(thrashing)
  - 페이지 폴트와 디스크 i/o
    - 페이지 폴트가 발생하면 필연적으로 디스크 i/o증가
  - 스래싱(Thrashing or Disk Thrashing)
    - 페이지 폴트가 계속 발생하여, 메모리 프레임에 페이지가 반복적으로 교체되고, 디스크 입출력이 심각하게 증가하고, CPU활용율이 대폭 감소하는 현상
    - 스래싱은 빈번한 페이지 폴트로 인한 디스크 입출력 증가 현상
    - 스레싱 도미노 현상 : 프로세스들이 페이지 적재를 두고 경쟁
  
  - 스래싱의 원인
    1. 다중프로그래밍 정도(Degree of multiprogramming)가 과한 경우
        
        메모리에 비해 너무 많은 프로세스가 실행되어, 프로세스스 당 할당되는 프레임 개수가 적을 때 프로세사가 필요한 충분한 페이지가 적재되지 못하여 페이지 폴트 발생
    2. 잘못된 메모리 할당/ 페이지 교체 알고리즘
    3. 기본적으로 메모리 할당량이 적을 때
    4. 우연히도 특정 시간에 너무 많은 프로세스 실행

  - 스래싱이 발생하는 시점
    - 다중프로그래밍 정도(DOM)가가 높아질수록 CPU활용률 증가
    - 다중프로그래밍 정도(DOM)가 임게점을 넘어가면 스래싱 발생


 - 스래싱 해결 및 예방
   - 다중프로그래밍 정도(DOM)줄이기
   - 하드 디스크 대신 빠른 SSD사용
   - 메모리 늘리기

## 4. 참조의 지역성과 작업 집합
 - 참조의 지역성
   - cpu가 짧은 시간 범위 내에 일정 구간의 메모리 영역을 반복적으로 참조하는 경향
 - 참조의 지역성 특징
   - 모든 프로그램에서 나타나는 기본적인 실행 특성
   - 짧은 시간에 특정 부분을 집중 참조
   - 최근에 참조한 데이터와 코드를 다시 참조하려는 경향성
   - 참조의 지역성 이동. 실행되는 동안 매모리 영역을 옮겨 다니면서 참조의 지역성이 나타남
   - 90/10 규칙
- 의미 
  - 현채 프로세스의 실행패턴 관찰을 통해 미래에 프로세스의 코드와 데이터 사용을 합리적으로 예측 -> 메모리 할당과 페이지 교체 전략에 활용

- 참조의 지역성 형태
  - 시간 지역성(Tempral Locality)
    - 프로세스에서 지금 참조된 주소(혹은 페이지)가 가까운 미래에 다시 참조될 가능성이 큰 특성
    - 반복문
  - 공간 지역성(Spatial Locality)
    - 지금 참조되는 번지의 주변 번지들이 가까운 미래에 참조되는 특성
    - 배열, 순차읽기/쓰기
- 작업 집합(working set)
  - 일정 시간 범위내에 프로세스가 액세스(참조)한 페이지들의 집합
  - 참조의 지역성으로 인해 일정 시간내에 작업 집합이 뚜렷하게 형성
    - 연속적인 페이지 폴트 -> 작업 집합 메모리 적재 중(작업 집합 형성 중)

- 작업 집합 이동(Working set shift)
  - 프로세스가 실행되는 동안 계속 작업 집합 이동
    - 페이지 폴트 수로 확인 가능
- 스래싱과 작업 집합
- 스레싱 예방 
  - 스래싱은 작업 집합이 메모리에 올라와 있지 않을 때 발생
  
- 요구 페이징의 필수 알고리즘
  - 프레임 할당(frame allocation) 알고리즘
    - 프로세스당 할당할 프레임 개수를 결정하는 문제
    - 작업 집학에 포함될 페이지들을 수용할 만한 개수의 프레임 할당 
  - 페이지 교체(page replacement) 알고리즘
    - 희생 프레임을 결정하는 문제
    - 작업 집합에 속하지 않은 페이지가 담긴 프레임을 선택

## 5. 프레임 할당
- 프레임 할당의 목표
  - 프로세스에게 작업 집합에 포함된 페이지들을 적재할 충분한 메모리 할당(페이지 폴트 및 스래싱 예방)
  - 균등 할당(equal allocation) 
    - 프로세스에게 크기에 관계없이 동일한 개수의 프레임 할당
    - 구현이 단순하지만 프레임 낭비와 빈번한 페이지 폴트 발생 가능성이 있음
  - 비례 할당(proportional alloction)
    - 프로세스 크기에 비례하여 프레임 할당
    - 페이지 폴트 발생 가능성이 낮지만, 실행전에 프로세스의 크기를 완벽히 알기 어려움(window의 프레임 할당사례 참고 10장 p.44)
  - 적정 프레임 개수 : 작업 집합을 약간 넘나드는 크기
  
## 6. 페이지 교체
메모리 프레임 중 하나를 선택하여 비유고 이곳에 요청된 페이지를 적재하는 과정
- 페이지 교체 알고리즘의 특징
  - 페이지 폴트 핸들러에서 실행되는 작업
  - 희생 프레임(victim frame) - 비우기로 선택된 프레임
  - 희생 페이지(victim frame) - 희생 프레임에 들어있는 페이지
  - 희생 페이지는 스왑-아웃, 요정 페이지는 스왑-인
- 페이지 교체 알고리즘의 목표
  - 현재 작업 집합에 포함되지 않거나 가까운 미래에 참조되지 않을 때 페이지를 희생 페이지로 선택, 페이지 폴트 횟수 감소
- 희생 프레임의 선택 범위
  - 지역 교체(local replacement)
    - 요청한 프로세스에 할당된 프레임 중에서 희생 프레임 선택
    - 한 프로세스에서 발생한 스래싱이 다른 프로세스로 전파되지 않음
  - 전역 교체(global replacement)
    - 전메 메모리 프레임 중에서 선택
    - 지역 교체보다 더 효과적

- 최근 컴퓨터 시스템의 구조 변화로 인한 시각 변화

  1. 전역 교체 방법은 큰 시간 소모
  2. 캐시의 중요성 부각
  3. 참조의 지역성 약화로 작업 집합이 모호
    - 객체 지형 언어 사용
    - 연결 리스트 사용
    - 가비지 컬렉션
- 페이지 교체 알고리즘의 종류
  - 최적 교체(Optimal Page Replacement)
    - 이론적으로 최고의 알고리즘
    - 가장 먼 미래에 사용될 페이지를 교체 대상으로 결정
  - FIFO(First in first out)
    - 가장 오래전에 적재된 페이지 선택
  - LRU(Least recently used)
    - 가장 최근에 사용되지 않았던 페이지 선택
    1. 타임 스탬프 이용
      
        참조 시간 기록 비트
      
        운영체제 교체 알고리즘 코드(참조시간이 가장 오래된 것 선택)
   
    2. 하드웨어 이용, 참조 비트 사용(Ref Bit)
        
        CPU가 페이지를 참조할 때마다 H/W로 참조 비트를 1로 설정

        운영체제 교체 알고리즘 코드(참조 값이 낮은 페이지 선택)

  - Clock
    - FIFO와 LRU를 섞은 방법
    - 프레임당 1비트의 참조 비트(reference bit/ used bit) 사용

      페이지가 참조될 때마다 프레임의 참조 비트를 1로 set
    - 희생 프레임 선택

      참조 비트가 0이면, 그 프레임을 희생 프레임으로 선택
      참조 비트가 1이면, 0으로 바꾸고 다음 프레임으로 이동
    
    