# 가상 메모리
## 1. 물리 메모리의 한계
- 컴퓨터에 설치할 수 있는 물리 메모리의 최대 크기
  
  CPU주소 버스 크기에 달려 있음. 실제 컴퓨터는 비용문제로 최대량이 미치치 못함.
  
  - 32bit CPU 물리 메모리 최대량 : 4GB
  
  - 64bit CPU 물리 메모리 최대량 : $2^{24}$TB

- 물리 메모리의 한계 극복
  - 설치된 물리 메모리보다 큰 프로세스를 실행? yes
  - 프로세스들을 합친 크키가 설치된 물리 메모리보다 클 때 이들 모두 실행? yes

## 2. 가상 메모리 개념
물리 메모리 크기의 한계계를 극복하기 위한 해결책

- 가상 매모리 기법의 핵심
  - 물리 메모리를 디디스크 공간으로 확장
  - 스와핑(swapping)
  1. 운영체제는 물리 메모리 영역을 하드 디스크로 연장
  2. 프로세스 실행시 프로세스 일부만 물리 메모리 적재
  3. 물리 메모리의 일부분을 하드 디스크로 옮김으로서 물리 메모리의 빈영역 확보
  4. 스왑 영역 : 물리 메모리를 확장하여 사용하는 디스크 영역
  5. 사용자는 무한대의 메모리가 있는 것으로 착각
   
- 가상 메모리 구현
  - 요구 페이징(demand paging) = 페이징 + 스와핑(swapping)
  - 요구 세그먼테이션(demand segmentation) = 세그먼트 스와핑

## 3. 요구 페이징
현재 실해엥 필요한 일부 페이지만 메모리에 적재하고 나머지는 하드디스크에 두고 페이지가 필요할 때 메모리에 적재하는 방식. 프로세스 페이지가 있는 디스크 영역 = 스왑 영역 + 실행 파일

- 페이지 테이블 항목
  - present/valid bit : 해당 페이지가 물리 메모리에 있는지 여부 
    - 1 : 프레임 번호의 메모리에 있음
    - 0 : 디스크에 있음

  - modified/dirty bit : 해당 페이지가 수정되었는지 여부
    - 1 : 프레임에 적재된 이후 수정됨 - 나중에 쫓겨날 때 스왑 아웃(디스크 저장)
    - 0: 수정된적이 없음 - 스왑 영역에 저장될 필요 없음

  - physical address
    - present bit = 1 : 적재되어 있는 프레임 번호
    - present bit = 0 : 디스크 블록 번호
- 페이지 폴트(page fault)
  - CUP가 액세스하려는 페이지가 물리 메모리에 없을 때 발생. MMU에서 논리 주소를 물리 주소로 바꾸는 과정에서 발생
    - 스왑 영역이나 실행 파일로 부터 빈프레임에 페이지 적재
  - 스왑 입(swap-in) = page-in
    - 페이지를 스왑 영역에서 프레임으로 읽어 들이는(복사) 행위
  - 스왑 아웃(swap-out) = page-out
    - 프레임에 저장된 페이지를 스왑 영역에 저장하고 프레임을 비우는 행위
  
- 실행
    
    1. 프로세스의 시작 페이지 물리 메모리에 적재
    2. 여러번의 페이지 폴트를 통해 실행 파일로부터 페이지들 적재
    3. 메모리가 부족하면 스왑-아웃/ 스왑-인
    4. 스왑-아웃된 페이지 100을 다시 스왑-인 
    5. 코드가 적재된 페이지(읽기 전용)이나 수정되지 않은 페이지가 희생 페이지로 선택된 경우 : 그 페이지는 프레임에서 버림. 이후 스왑 영역이나 실행 영역에서 적재

- 쓰기 시 복사 (COW, copy on write)
  - 부모 프로세스가 fork() 시스템 호출로 생성
  - fork() 자식 프로세스의 메모리 생성 방법
    
    
    1. 완전 복사 : 부모 프로세스의 모든 페이지를 완전히 복사

        많은 응용프로그램들이 fork() 후 생성된 자식 프로세스가 execlp()를 호출하여 곧 바로 다른 프로그램을 실행하도록 작성되기 때문에 비효율적임.
    2. 쓰기 시 복사 : 부모 프로세스의 페이지 테이블만 복사. 자식이나 부모가 페이지를 수정할 때 부모 프레임을 복사.
    
        프로세스 생성이 매무 빠름. 부모아 자식 프로세스가 둘 다 읽기만 하는 페이지는 새로운 프레임을 할당할 필요가 없으므로 메모리 절약




    

