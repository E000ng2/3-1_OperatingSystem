# 페이징 메모리 관리

## 1. 페이징 메모리 관리 개요
- 페이지와 프레임 
        
  - 페이지(page) : 프로세스의 논리 주소 공간을 0번지부터 동일한 크기로 나눈 것. 주로 4KB
  - 프레임(frame) : 물리 메모리를 0번지부터 페이지 크기로 나눈 것 
  - 페이지 테이블 : 페이지 번호와 프레임 번호를 1:1로 저장하는 테이블

- 페이징 기법

  프로세스의 논리 주소 공간과 물리 메모리를 페이지 단위로 분할하고, 프로세스의 각 페이지 물리 메모리의 프레임에 분산 할당아혀 관리하는 기법

  - 프로세스마다 페이지 페이블이 존재
  - 내부 단편화 발생
  - 세그먼트보다 우수

- 페이징의 우수성 
  - 용이한 구현
  - 높은 이식성
  - 높은 융통성
  - 메모리 활용과 시간 오버헤드면에서 우수(외부 단편화 없음, 내부 단편화 매무 작음)

 
- 예제

    32비트 cpu에서 페이지 크기가 4KB인 경우

    Q1 물리 메모리의 최대 크기?
        $4GB$

    Q2 프로세스의 주소공간의 크기?
        $4GB$

    Q3 한 프로세스는 최대 몇 개의 페이지로 구성?
        $\frac{2^{32}}{2^{12}} = 2^{20}$

    Q4 프로세스당 하나의 페이지 테이블의 크기?
        $4Byte * 2^{20} = 4MB$

    Q5 응용프로그램의 최대 크기, 즉 개발가자 작성할 수 있는 프로그램의 최대 크기?
        운영체제가 설정한 사용자 공간의 크기와 동일
     
    Q6 페이지 테이블 모양? 
        대부분의 항목이 비어있는 희소 테이블(sparse table)
    
    Q7 페이지 테이블 저장 위치?
        메모리
    
    Q8 커널코드는 어떤 주소 체계로 저장?
        논리 주소. 터널코드가 실행될 때 프로세스의 페이지 테이블을 이용해 물리 주소로 변환

**외부 단편화 발생 없음 / 내부 단편화 발생(스택, 힙 페이지 제외시 마지막 페이지에서만 발생생)**

## 2. 페이징의 주소 체계
- 논리 주소 구성 : [페이지 번호(p), 옵셋(offset)] * 옵셋 : 페이지 안에서의 위치

- 32비트 논리 주소 체계
    
    상위 20비트 : 페이지 번호
    하위 12비트 : 옵셋 

- 페이징 구현
  - 하드웨어 지원
    
    CPU : 페이지 테이블(PTBR)이 있는 물리 메모리 주소를 가진 레지스터

    MMU지원 : 논리 주소의 물리 주소 변환 장치

  - 운영체제 지원

    물리 프레임의 동적 할당/반환

    페이지 테이블 관리 기능 구현

    페이지 테이블의 물리 메모리 주소를 CPU의 PTBR에 적재

## 3. 페이지 테이블의 문제점과 TLB
- 문제 1 
    
    1번에 메모리 액세스를 위해 2번의 물리 메모리 액세스가 필요
    
    2번 = 페이지 테이블 학목 읽기 1번 + 데이터 엑세스 1번

  - 해결방안 -> TBL(Translation Look-aside Buffer)사용
    
    - 주소변환 캐시(address translation cache)로도 불림, 최근에 접근한 페이지 번호와 프레임 번호의 쌍으로 항목을 저장하는 캐시 메모리
    - MMU내에 존재
    - [페이지 번호 p, 프레임 번호 f]
    - TLB에 페이지 번호가 있는 경우 : TLB hit
    - TLB에 페이지 번호가 없는 경우 : TLB miss
  - TLB
    - 순차 메모리 액세스 시 실행 속도 빠름
    - 랜덤 메모리 액세스 시 실행 속도 느림(TLB잦은 항목 교체)
    - TLB 히트률 <-> TLB 항목 늘이기(비용과 trade-off)
    - 페이지 크기
      - 크기가 클수록 TLB히트 증가
      - 크기가 클수록 내부 단편화 증가
    - TLB reach
      - TLB를 통해 접근할 수 있는 메모리 크기
        
        TLB 항목 수 * 페이지 크기



- 문제 2
    페이지 테이블 낭비

  - 해결방안-> 역 페이지 테이블(inverted page table, IPT), 멀티레벨 페이지 테이블(multi-level page table)
  - 역 페이지 테이블(inverted page table, IPT)

    물리 메모리 전체 프레임에 대해, 각 프레임이 어떤 프로세스의 어떤 페이지에 할당되었는지를 나타내는 테이블

    - 시스템 당 역 페이지 테이블 1개 : 역 페이지 항목의 수 = 물리 메모리의 프레임 개수
    - [프로세스 번호(pid), 페이지 번호(p)]
    - 항목 번호가 프레임 번호
    - 기존 테이블과의 비교
      ```
      32비트 cpu사용, 페이지와 프레임 크기 4KB, entry는 각각 4Byte 8Byte, 10개의 프로세스가 실행 중, 물리 메모리의 크기는 4GB이다.
      기존 페이지 테이블의 크기? 4MB*10개 = 40MB
      역 페이지 테이블의 크기? 8MB
      ```
  - 멀티 레벨 페이지 테이블(multi-level page table)

    현재 사용중인 페이지들에 대해서만 페이지 테이블을 만듦. 페이지 테이블을 여러개의 작은 페이지 테이블로 나누고 이들은 여러 레벨로 구성
        
    - [페이지 디렉터리 인덱스, 페이지 테이블 인덱스, 옵셋]
    - 기존 데이블과의 비교
      ```
      32비트 cpu사용, 페이지와 프레임 크기 4KB, entry는 각각 4Byte 8Byte, 10개의 프로세스가 실행 중, 물리 메모리의 크기는 4GB이다.
      2-레벨 페이지 테이블의 최대 메모리 소모량?
        페이지 디렉토리 테이블 1개 + 페이지 테이블 1024개
        4KB * 1 + 4KB * 1024  = 4KB + 4MB
      프로세스가 1000개의 페이지로 구성되는 경우
        페이지 디렉토리 테이블 1개 + 페이지 테이블 1개
        4KB + 4KB = 8KB
      프로세스가 400MB인 경우
        페이지 개수 = 100*1024개 = 100개의 페이지 테이블 필요
        페이지 디렉토리 테이블 1개 + 페이지 테이블 100개 
        4KB + 4KB * 100 = 404KB
      ```





